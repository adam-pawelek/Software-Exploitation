# Assignment: Shellcode

This assignment is based on the  **shell\_1**. The program has three modes of input: _argument_, _file_ and _standard input_. Each input mode reads an input into a buffer and passes it to a function with a buffer-overflow vulnerability.

**Part 1: arbitrary code execution**

Create a shellcode (shellcode generated with metasploit won&#39;t do) for the different inputs for  **shell\_1**. You can have three different shellcodes or use the same shellcode for all inputs. The examples below say  **Hello, world.**  but you should use some other message in your shellcode.

1. Execute shellcode from standard input:
2. $ cat FILE | ./shell\_1 -f -
3. Hello, world.
4.
5. $ ./shell\_1 -f - \&lt; FILE

Hello, world.

1. Execute shellcode from file:
2. $ ./shell\_1 -f FILE

Hello, world.

1. Execute shellcode from command-line parameter:
2. $ ./shell\_1 -c TEXT

Hello, world.

Getting the print is enough, but exiting with _exit code_  **0**  grants more points.

You can base the shellcode on  **hello.asm**  and make a version of it that works as a shellcode (see _Hacking, 2nd Edition_, chapter 0x500).

**Part 2: command shell**

Second part of the assignment is to create, choose, or generate a shellcode that executes a system command. It is up to you to decide what the command is and what input method you want to use.

You should note that spawning an interactive shell is a good exercise when compared to simply executing a command. There are some complications with an interactive shell that you will sadly avoid with non-interactive commands. But again, the choice is yours.

You should also make sure to include the shellcode (in assembly) as well as a description of how it works in the report.

**Word about inputs**

_Pipe_ works by directing output of one program program to the standard input of another program. If you want to pipe the contents of a file, you can use something like  **cat** , which is a standard utility program for concatenating files. It reads files given as arguments and outputs the contents to standard output. So to pipe the contents of  **FILE** , you can use following:

cat FILE | ./shell\_1 -f -

Another option is to \_redirect\_ file to standard input. The following example redirects a file to the standard input using shell:

./shell\_1 -f - \&lt; FILE

The last input mode is reading the shellcode from a command-line parameter:

./shell\_1 -t TEXT

I will leave the details to the reader, but _command substitution_ is probably the best approach in this case.

**Hand in**

The assignment will be graded based on the report. The report should give a clear solution to the assignment as well as how you arrived to the solution. Avoid copy-pasting every command and output into the report. Rather, you should put effort into explaining your though process when you were solving the assignment:

1. What is the problem you are trying to solve?
2. How are you going to approach the problem?
3. What did you do?
4. Did the approach work?
5. Do you need to change your approach?

You can repeat the loop until you come to a solution you are happy with. There is no point in explaining the same steps over and over, but it is good idea to note them for the first time.

1. Finally summarize your findings.

The above is just one way to write the report. While it is not a great fit for professional report, it is a straightforward approach to school assignment since it gives structure to your research.

The reports should also include enough information so that the test setup can be replicated if necessary. This includes the platform, compiler tool chain and the details for the generated binary:

- Platform used for testing the program
  - Use  **uname -a**  to get full system information on Linux
- Tools used to compile the program
  - If using GCC use  **gcc --version**  to get the compiler version
- Also tell what architecture the program was compiled for
  - Use  **readelf -h**  or  **file**  to get that information

In addition to the system information the report should also detail how the program was compiled and what kind of a build artifact was generated:

- Commands used to compile the program
  - If the included  **Makefile**  was used it is enough to simply mention that

Finally, include the inputs used as well as the output generated with the given input.

Keep record of time used and include that in the report.
